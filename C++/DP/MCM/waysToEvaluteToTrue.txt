ou are given an expression 'exp' in the form of a string where 
operands will be : (TRUE or FALSE), and operators will be : (AND, OR or XOR).
Now you have to find the number of ways we can parenthesize the expression such that it will evaluate to TRUE.
As the answer can be very large, return the output modulo 1000000007.
Note :
‘T’ will represent the operand TRUE.
‘F’ will represent the operand FALSE.
‘|’ will represent the operator OR.
‘&’ will represent the operator AND.
‘^’ will represent the operator XOR.


long long solve(int i, int j, int isTrue, string& exp, vector<vector<vector<long long>>>& dp){//TODO
    if(i>j) return 0;
    if(i==j){
        if(isTrue) return exp[i]=='T';
        else return exp[i]=='F';
    }
    if(dp[i][j][isTrue]!=-1) return dp[i][j][isTrue];
    long long ways = 0;
    int mod = 1000000007;
    for(int k=i+1;k<=j-1;k+=2){
        long long lt = solve(i,k-1,1,exp,dp);        
        long long rt = solve(k+1,j,1,exp,dp);
        long long lf = solve(i,k-1,0,exp,dp);
        long long rf = solve(k+1,j,0,exp,dp);
        if(exp[k] == '&'){
            if(isTrue) ways = (ways + lt * rt)%mod;
            else ways = (ways + (lt * rf + lf * rt + lf * rf))%mod;
        }else if(exp[k] == '|'){
            if(isTrue) ways = (ways + (lt * rf + lf * rt + lt * rt))%mod;
            else ways = (ways + lf * rf)%mod;
        }else{
            if(isTrue) ways = (ways + (lt * rf + lf * rt))%mod;
            else ways = (ways + (lt * rt + lf * rf))%mod;
        }
    }
    return dp[i][j][isTrue]=ways;
}


int evaluateExp(string & exp) {
    int n=exp.length();
    vector<vector<vector<long long>>> dp(n,vector<vector<long long>>(n,vector<long long>(2,-1)));
    return solve(0,n-1,1,exp,dp);
}


//Tabulation

    int evaluateExp(string & exp) {
        long long mod=1000000007;
        int n=exp.length();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(n,vector<int>(2,0)));
        for(int i=n-1;i>=0;i--)
        {
            for(int j=i;j<n;j++)
            {
                if(i==j)
                {
                    dp[i][j][0]=(exp[i]=='F');
                    dp[i][j][1]=(exp[i]=='T');
                }
                else 
                {
                    long long ways=0;
                    for(long long ind=i+1;ind<=j-1;ind+=2)
                    {
                        long long lt=dp[i][ind-1][1]%mod;
                        long long rt=dp[ind+1][j][1]%mod;
                        long long lf=dp[i][ind-1][0]%mod;
                        long long rf=dp[ind+1][j][0]%mod;
                        if(exp[ind]=='&')
                        {
                            dp[i][j][0]=(dp[i][j][0]+(lt*rf+lf*rt+lf*rf))%mod;
                            dp[i][j][1]=(dp[i][j][1]+(lt*rt))%mod;
                        }
                        else if(exp[ind]=='|')
                        {
                            dp[i][j][0]=(dp[i][j][0]+(lf*rf))%mod;
                            dp[i][j][1]=(dp[i][j][1]+(lt*rf+lf*rt+lt*rt))%mod;
                        }
                        else
                        {
                            dp[i][j][0]=(dp[i][j][0]+(lt*rt+lf*rf))%mod;
                            dp[i][j][1]=(dp[i][j][1]+(lt*rf+lf*rt))%mod;
                        }
                    }
                }
            }
        }
        return dp[0][n-1][1];
    }