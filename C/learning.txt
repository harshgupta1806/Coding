-> C++ supports OOPs paradigm while C only has the procedural concept of programming.
-> C++ has exception handling capabilities. In C, we have to resolve exceptions manually.
-> There are no references in C.

-> In a procedural language like C step by step, predefined instructions are carried out
-> C programming language is a statically typed language. Meaning the type of variable is checked at the time of compilation but not at run time

-> Features
https://media.geeksforgeeks.org/wp-content/uploads/20200214125122/Features-of-C-Programming-Language.jpg

-> As it is a middle-level language so it has the combined form of both capabilities of assembly language and features of the high-level language.
-> Using puts() Function
    #include <stdio.h>
    int main() {
        puts("Hello, World!");
        return 0;
    }

-> Using write() System Call
    int main() {
        write(1, "Hello, World!\n", 14);
        return 0;
    }
    -> Include unistd.h: Since write() is a system call, it requires <unistd.h>.
    -> Return Value: write() returns the number of bytes written.

-> As C is a mid-level language, it needs a compiler to convert it into an executable code so that the program can be run on our machine.
   https://media.geeksforgeeks.org/wp-content/uploads/20230404112946/Compilation-Process-in-C.png


-> A compiler converts a C program into an executable. There are four phases for a C program to become an executable: 
1.Pre-processing(to veiw -> $vi filename.i)
    ->Removal of Comments
    ->Expansion of Macros
    ->Expansion of the included files.
    ->Conditional compilation

2.Compilation(to veiw -> $nano filename.s)
    ->produce an intermediate compiled output file filename.s

3.Assembly(to veiw -> $vi filename.0)
    ->This file contains machine-level instructions. 
    ->At this phase, only existing code is converted into machine language.
    ->The function calls like printf() are not resolved.

4.Linking
    ->All the linking of function calls with their definitions is done.
    ->It adds some extra code to our program which is required when the program starts and ends.
    ->The output file increases from an object file to an executable file. 
    ->This is because of the extra code that Linker adds to our program. 

TOKENS:
    6 types
        Keywords
        Identifiers (It should be up to 31 characters long as only the first 31 characters are significant.)
        Constants
        Strings
        Special Symbols
        Operators

->  doubles have 15 decimal digits, and floats only have 7.
-> int -> -32768 to +32767

Here's the information formatted as a table:

| Data Type               | Memory (bytes) | Range                                 | Format Specifier           |
|-------------------------|----------------|---------------------------------------|----------------------------|
| `short int`             | 2              | -32,768 to 32,767                     | `%hd`                      |
| `unsigned short int`    | 2              | 0 to 65,535                           | `%hu`                      |
| `unsigned int`          | 4              | 0 to 4,294,967,295                    | `%u`                       |
| `long int`              | 4              | -2,147,483,648 to 2,147,483,647       | `%ld`                      |
| `unsigned long int`     | 4              | 0 to 4,294,967,295                    | `%lu`                      |
| `long long int`         | 8              | -(2^63) to (2^63)-1                   | `%lld`                     |
| `unsigned long long int`| 8              | 0 to 18,446,744,073,709,551,615       | `%llu`                     |
| `signed char`           | 1              | -128 to 127                           | `%c`                       |
| `unsigned char`         | 1              | 0 to 255                              | `%c`                       |
| `long double`           | 16             | 3.4E-4932 to 1.1E+4932                | `%Lf` or `%lf` for double  |


AUTO
    ->The default storage class for local variables within a function. 
    ->They are stored in stack memory, have local scope, and automatic duration 
    (created when the function is called and destroyed when it returns).

REGISTER
    ->Suggests to the compiler to store the variable in a CPU register for faster access
    ->Typically used for variables that require quick access, like loop counters
    ->Modern compilers manage this automatically, so register is rarely necessary.

STATIC	
    ->Used to extend the lifetime of a variable to the entire program's runtime.
    ->Though its scope remains local. If declared inside a function, 
    a static variable retains its value across multiple function calls. 
    ->When used at the global level, it restricts the visibility of the variable or function to the current file (internal linkage).

EXTERN	
    ->Declares a global variable or function that can be used across multiple files. 
    ->It does not define memory for the variable but indicates that the variable or 
    function exists elsewhere, usually in another file.
    ->The extern variable says to the compiler  “Go outside my scope and you will find the definition of the variable that I declared.”
    The compiler believes that whatever that extern variable said is true and produces no error. Linker throws an error when it finds no such variable exists.
    When an extern variable is initialized, then memory for this is allocated and it will be considered defined.

C Version	Number of Keywords	Description
  C89/C90	              32
    C99	                  37
    C11                   44  
    C23                   46  

VOLATILE
    ->used to inform the compiler that a variable's value may change at any time, 
    without any action being taken by the code itself.
    ->the variable could be modified by an external factor that the compiler may not anticipate, 
    such as hardware, an interrupt service routine, or another thread in a concurrent program.
    ->volatile only prevents optimization of reads and writes to a variable
    ->It does not provide any protection against concurrent access by multiple threads. 
    For that, use synchronization mechanisms like mutexes or atomic operations.
    

C Variable Types

    Local Variables
    Global Variables
    Static Variables(default value of static variables is 0)
    Automatic Variables(default value of automatic variables is garbage)
    Extern Variables
    Register Variables(default value of register variables is garbage)

QUALIFIERS

    QUALIFIERS are keywords that are used to modify the behavior or properties of variables. 
    They provide additional information to the compiler about how a variable should be treated. 
    There are four primary qualifiers in C:

        const
        volatile
        restrict (introduced in C99)
        _Atomic (introduced in C11)

    const	
        ->Makes a variable read-only. Its value cannot be modified after initialization.	
        use case -> Defining constants, protecting data from alteration
    volatile	
        ->Informs the compiler that the variable's value may change unexpectedly, 
        preventing certain optimizations.	
        use case -> Hardware registers, variables modified by ISR
    restrict
        ->Tells the compiler that a pointer is the only reference to the object it points to, 
        enabling optimizations.	
        use case -> Pointer arguments in performance-sensitive code
    _Atomic	
        ->Ensures atomic access to a variable, 
        making it safe to use in concurrent programming without explicit locking mechanisms.	
        use case -> Multi-threaded applications, shared variables

Scoping is generally divided into two classes: 
1. Static Scoping 
    In static scoping the compiler first searches in the current block, then in global variables, then in successively smaller scopes.
2. Dynamic Scoping
    In Dynamic scoping the compiler first searches in the current block, then in the bloack from where the current block is called.

C scope rules can be covered under the following two categories:
1. Global Scope
2. Local Scope


Scope : Scope of an identifier is the part of the program where the identifier may directly be accessible
Linkage : Linkage describes how names can or can not refer to the same entity throughout the whole program or one single translation unit.
Translation Unit : A translation unit is a file containing source code, header files and other dependencies. All of these sources are grouped together to form a single translation unit which can then be used by the compiler to produce one single executable object.

->scope is a property handled by compiler, whereas linkage is a property handled by linker.
->The Linker is a program that takes multiple machine code files as input, and produces an executable object code.
->scope is a concept that can be used only during compile phase. After the program is compiled there is no such concept as “scope of variable”.


There are 2 types of linkage:
Internal Linkage:
    ->An identifier implementing internal linkage is not accessible outside the translation unit it is declared in
    ->It is implemented by the keyword static. 
    ->An internally linked identifier is stored in initialized or uninitialized segment of RAM.
    ->Only implemented when the variable has global scope
    ->All constants are by default internally linked.

External Linkage: 
    ->An identifier implementing external linkage is visible to every translation unit
    ->shared between translation units
    ->default linkage for globally scoped variables and functions.
    ->It is implemented by the keyword Extern.
    ->Extern identifiers are generally stored in initialized/uninitialized or text segment of RAM.



| Types                     |  Description                                    | Examples                                 |
|---------------------------|-------------------------------------------------|------------------------------------------| 
| Primitive Data Types      | Basic data types for representing simple values | `int`, `char`, `float`, `double`, `void` |
| Derived Types             | Data types derived from primitive data types    | `array`, `pointers`, `function`          |
| User-Defined Data Types   | Data types defined by the user                  | `structure`, `union`, `enum`             |


Integer -> Range: -2147483648 to 2147483647
Float -> Range: 1.2E-38 to 3.4E+38
short int -> Range: -32,768 to 32,767
Double -> Range: 1.7E-308 to 1.7E+308

4 data type modifiers;
    short Modifier(decreases the size of the int to 2 bytes)(used with only int)
    long Modifier(increase the original size by 2 times)(with -> long int,long long int,long double)
    unsigned Modifier(unsigned modifier shifts the data type range to the positive part of the whole numbers)
    signed Modifier(default modifier of int and char data type)

Types of C Literals
    Integer Literal(0->octal, 0x->hexa, 0b or 0B->binary)
    Float Literal
    Character Literal
    String Literal

Here’s the escape sequence table:

| Escape Sequence | Name               | Description                                                   |
|-----------------|--------------------|---------------------------------------------------------------|
| `\a`            | Alarm or Beep      | Generates a bell sound in the program.                        |
| `\b`            | Backspace          | Moves the cursor one place backward.                          |
| `\f`            | Form Feed          | Moves the cursor to the start of the next logical page.       |
| `\n`            | New Line           | Moves the cursor to the start of the next line.               |
| `\r`            | Carriage Return    | Moves the cursor to the start of the current line.            |
| `\t`            | Horizontal Tab     | Inserts whitespace to the left of the cursor and moves it.    |
| `\v`            | Vertical Tab       | Inserts vertical space.                                       |
| `\\`            | Backslash          | Inserts a backslash character.                                |
| `\'`            | Single Quote       | Displays a single quotation mark.                             |
| `\"`            | Double Quote       | Displays double quotation marks.                              |
| `\?`            | Question Mark      | Displays a question mark.                                     |
| `\ooo`          | Octal Number       | Represents an octal number.                                   |
| `\xhh`          | Hexadecimal Number | Represents a hexadecimal number.                              |
| `\0`            | NULL               | Represents the NULL character.                                |
| `\e`            | Escape Sequence    | Represents the ASCII escape character.                        |
| `\s`            | Space Character    | Represents the ASCII space character.                         |
| `\d`            | Delete Character   | Represents the ASCII DEL character.                           |

This table provides a clear overview of each escape sequence, its name, and its function.

Type Conversion
    https://media.geeksforgeeks.org/wp-content/cdn-uploads/Implicit-Type-Conversion-in-c.png
A. Done by the compiler on its own, without any external trigger from the user.
B. Generally takes place when in an expression more than one data type is present. In such conditions type conversion (type promotion) takes place to avoid loss of data.
C. All the data types of the variables are upgraded to the data type of the variable with the largest data type.

Adv:
    Improved data storage
    Improved data manipulation
    Improved compatibility
    mproved performance
    Improved code readability
    Type safety
Dis:
    Slower performance
    Increased complexity
    Confusing syntax
    Unexpected behavior
    Overflow or underflow
    Loss of precision

->
    printf("\n\nEnter the Sentence: ");
    scanf("%[^\n]s", str);

https://www.geeksforgeeks.org/format-specifiers-in-c/

| Format Specifier | Description                                 |
|------------------|---------------------------------------------|
| `%c`             | For character type                          |
| `%d`             | For signed integer type                     |
| `%e` or `%E`     | For scientific notation of floats           |
| `%f`             | For float type                              |
| `%g` or `%G`     | For float type with the current precision   |
| `%i`             | For signed integer                          |
| `%ld` or `%li`   | For long integer                            |
| `%lf`            | For double type                             |
| `%Lf`            | For long double type                        |
| `%lu`            | For unsigned int or unsigned long           |
| `%lli` or `%lld` | For long long integer                       |
| `%llu`           | For unsigned long long integer              |
| `%o`             | For octal representation                    |
| `%p`             | For pointer address                         |
| `%s`             | For string                                  |
| `%u`             | For unsigned int                            |
| `%x` or `%X`     | For hexadecimal representation              |
| `%n`             | Prints nothing (stores the number of characters printed so far in an integer variable) |
| `%%`             | Prints `%` character                        |


Input and Output Formatting
    A minus(-) sign tells left alignment.
    A number after % specifies the minimum field width to be printed if the characters are less than the size of the width the remaining space is filled with space and if it is greater then it is printed as it is without truncation.
    A period( . ) symbol separates field width with precision.

->Precision tells the minimum number of digits in an integer, the maximum number of characters in a string, and the number of digits after the decimal part in a floating value.

int main()
{
    char str[] = "geeksforgeeks";
    printf("%20s\n", str);
    printf("%-20s\n", str);
    printf("%20.5s\n", str);
    printf("%-20.5s\n", str);
    return 0;
}
O/P->
       geeksforgeeks
geeksforgeeks       
               geeks
geeks  


printf ->
    Return Value
        -> printf() returns the number of characters printed after successful execution.
        -> If an error occurs, a negative value is returned.
    
    Syntax of Format Specifier
        %[flags][width][.precision][length]specifier

        Width(white space will be used to fill the remaining characters’ places)(no cut offs)
            printf("%25s", some_string);
            or
            printf("%*s", 25, some_string);
        Precision
            printf("%.10d", some_integer);(minimum number of digits to be printed -> 0 padding)
            printf("%.3f", some_float);(number of digits to be printed after the decimal point.)
            printf("%.25s", some_string);(length of the string to be printed.)
            or
            printf("%.*d", 10,  some_integer);
            printf("%.*f", 3, some_float);
            printf("%.*s", 25, some_string);
        Length
            h: With short int and unsigned short int
            l: With long int and unsigned long int.
            L: With long double
        
sprintf(string print)->
    Syntax: 
        int sprintf(char *str, const char *string,...); 
    Return: 
        If successful, it returns the total number of characters written excluding 
        null-character appended in the string, in case of failure a negative number is returned .
    ```
    sprintf(buffer, "Sum of %d and %d is %d", a, b, c);
    // The string "sum of 10 and 20 is 30" is stored
    // into buffer instead of printing on stdout
    printf("%s", buffer);
    ```

scanf->
    The scanf in C returns three types of values:
        >0: The number of values converted and assigned successfully.
        0: No value was assigned.
        <0: Read error encountered or end-of-file(EOF) reached before any assignment was made.

sscanf(string scan)->
    ->reads data from the string or character array instead of the console screen.
    ```
    sprintf(str, "a = %d and b = %d", a, b); 
    // The value of a and b is now in c and d 
    sscanf(str, "a = %d and b = %d", &c, &d)
    
    o/p ->  c = 2 and d = 8
    ```

Scansets->
    ->Represented by %[]
    ->case sensitive
    ->example: scanf(%s[A-Z,_,a,b,c]s,str);
    ->read all characters but stops after first occurrence of ‘o’ 
        scanf("%[^o]s", str);
    ->gets() -> until either a terminating newline or EOF found.
        scanf("%[^\n]s", str);
    
Unformatted Input/Output functions->
    getch();(conio.h)
        ->reads a single character from the keyboard(doesn’t display that character)
        ->Syntax-> getch(); or variable-name = getch();
    getche();(conio.h)
        ->reads a character and displays immediately 
    getchar();(stdio.h)
        ->read only a first single character from the keyboard whether multiple characters is typed.
        ->until and unless the enter key is pressed
    putchar();(stdio.h)
        ```
        // Reads a character 
        ch = getchar(); 
        // Displays that character 
        putchar(ch); 
        ```
    gets();(stdio.h)
        ->write space-separated texts or strings
        ->reads a group of characters or strings
    puts();
        ->display a group of characters or strings which is already stored in a character array
    
    
OPERATORS:
https://media.geeksforgeeks.org/wp-content/uploads/20231214120748/Operators-in-C.png

Methods of Parameter Passing
    Pass by Value
    Pass by Reference
    1. Pass by Result
    2. Pass by Value-Result
    3. Pass by Name

