// check k th bit set/unset
    1. (n & (1<<(k-1))) != 0 --> true if bit is set
    2. (n>>(k-1) & 1) != 0 -> true if bit is set

// count set bits
    1.theta(total bits)-> right shifting and checking lsb
    2.Brian Kernighan's Algorithm
        (subtract 1 from a no. then all unset bits after the last set bit becomoes set and last set bit gets unset)
        ->theta(total set bits)
        int countSetBits(int n){
            int res=0;
            while(n){
                n=n&(n-1);
                res++;
            }
            return res;
        }
    3.constant time + preprocessing
        int table[256];//storing no. of set bits in all 255 nos
        table[0]=0;
        for(int i=1;i<256;i++){
            table[i]=(i&1) + table[i/2];
        }
        int res=0;
        res+=table[n & 0xff];
        n=n>>8;
        res+=table[n & 0xff];
        n=n>>8;
        res+=table[n & 0xff];
        n=n>>8;
        res+=table[n & 0xff];
        return res;

//pow(2,k)==(1<<k)

// check if pow of 2
    (n & (n-1)) == 0  -> true if pow of 2

//XOR
    x ^ 0 = x
    x ^ x = 0

upr to lower
    char | ' ' //or with 32(set 5th bit)

lower to upr
    char & '_' //and with ~32(unset 5th bit)

count of set bits till N
/*
    int d=2,sum=0;
    while(N){
        sum += ((N+1)/d)*(d/2) + max((N%d)-d/2 , 0);
        d*=2;
    }
*/

//pos(rightmost pos is 1) of first set bit-->>
    log(n & ~(n-1)) + 1

// XOR of 1 -> n
    if(n%4==0) return n;
    if(n%4==1) return 1;
    if(n%4==2) return n+1;
    if(n%4==3) return 0;